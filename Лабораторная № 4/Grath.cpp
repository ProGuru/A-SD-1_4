#include <iostream>
#include <vector> // динамический массив
#include <list> // список
#include <stack> // стек

using namespace std;
const int MaxV = 26; // макс. кол-во лат. букв
char Ch(int c) // функция возвращает номер символа в соответствии с его порядком
{ return c + 'a'; }

class GR 
{
  int num, n, m; // используются для индексации и прочее
  vector <list<int>> LIST; // массив из целочисленных элементов для формирования списка смежности
  vector <int> NUM, L; // вектор из целочисленных элементов, NEW вектор пройденных вершин
  stack<pair<int, int>> STACK; // стек из пары целочисленных элементов
  void DBL (int v, int p); // ?????????? ДЛЯ ЧЕГО ??????????
public:
  GR(int); // конструктор
  void DBL_Exec(); // ?????????? ДЛЯ ЧЕГО ??????????
  ~GR() = default; // деструктор
};

GR :: GR(int MaxV) : num(0), n(0), m(0) // описание конструктора. Задание графа
{ 
  int G[ MaxV ][ MaxV ]; // метрица смежности
  string s; // переменная для ввода строки букв - т. е. меток смежных вершин

	for(int i = 0; i < MaxV; ++i) // заполнение матрицы смежности нулями
    for(int j = 0; j < MaxV; ++j) 
    G[ i ][ j ] = 0;

 	cout << "\n Введите мн-ва смежности (строки букв a до z)\n";

  do{ // заполнение матрицы смежности
	  cout << "v[" << Ch(n) << "]="; // Ch(n) - вывод символа на экран
    cin >> s; // ввод смежных вершин

    for (auto i : s) // цикл foreach. переменной i автоматически приписывается тип char 
      if (isalpha( i )) // проверка, является ли символ буквой
      {
      int j = (tolower( i ) - 'a'); // получение порядкового номера латинской буквы
      G[ n ][ j ] = G[ j ][ n ] = 1; // матрица смежности делается симметричной
      }

	  ++n;
  } while(isalpha(s[0]) && n < MaxV);

  // ФОРМИРОВАНИЕ СПАСКА СМЕЖНОСТИ

  n = m = 0; // n - количество вершин, m - количество рёбер
  LIST.resize(MaxV); // под массив выделяется MaxV элементов

  for (int i=0; i<MaxV; ++i)
  {
    int f = 0;
    cout << '\n' << Ch(i) << ": "; // вывод каждой буквы из алфавита на экран

	  for (int j = 0; j < MaxV; ++j) // из матрицы смежности формируется список смежности
      if(G[ i ][ j ]) // если элемент существует
	    { 
        ++f; // подсчёт количества связей для одного узла
	      LIST[ i ].push_back(j); // заполнение массива
	      cout << Ch( j ) << ' '; // вывод на экран смежной вершины
	    }
      else cout << "- ";

	  m += f; // подчсёт количества рёбер

	  if (f) ++n; // количество вершин
	  else break;
  }
  cout << "\n|V|=" << n <<  " |E|=" << m/2; // |V| - мощность множества вершин (количество вершин), |E| - мощность множества (количество связей)
}

void GR :: DBL_Exec() //Обход графа в целом, возможно, несвязного
{
  NUM.resize(n, 0); // вектор из n элементов, заполняется 0
  L.resize(n, 0); // вектор из n элементов, заполняется 0

  for (int i = 0; i < n; ++i)
	  if (!NUM[ i ]) DBL( i, -1 ); // просматриваем все вершины
}

void GR :: DBL (int i, int p) //Обход компоненты связности
{ 
  using edge = pair<int, int>; // пара элементов int
  NUM[ i ] = L[ i ] = ++num; // к векторам в зависимости от индекса прибавляется инкрементированное значение num (помечаем что вершина пройдена????)

  // в списке NUM отмечаются пройденные вершины, в L путь

  for (int u : LIST[ i ]) // рассматриваем каждую смежную вершину из списка смежности
  {   
    if (!NUM[ u ]) // если смежная вершина ещё не была рассмотрена ...
	  {  
      edge e0(u,i), e1(0,0); // u - смежная вершина; i - рассматриваемая вершина = ребро
      STACK.push(e0); // ребро -> в стек, чтобы потом вывести на экран
      DBL(u, i); // рекурсивная функция, в качестве аргумента передаётся текущее ребро

      L[ i ] = L[ u ] < L[ i ] ? L[ u ] : L[ i ]; // ищем минимальный путь

      if (L[ u ] >= NUM[ i ])
      {
        cout << "\n ребро <" << Ch(i) << '-' << Ch(u) << "> замыкает компоненту [";

        do { //выдача компоненты двусвязности
          e1 = STACK.top(); 
          STACK.pop();
          cout << Ch(e1.first) << '-' << Ch(e1.second) << ';' ;
        } while ((e1 != e0) && !STACK.empty());

        cout << "] ";
      }
    } // if (NUM…
    else if ((u != p) && (NUM[ u ] < NUM[ i ]))
    { 
      STACK.push(make_pair(u, i));
      L[ i ] = NUM[ u ] < L[ i ] ? NUM[ u ] : L[ i ];
    }
  } //  for…
}

int main()
{
  setlocale(LC_ALL, "Russian");
  cout << "\nDBL test ============== (C)lgn, 10.10.03;24.02.20";
  GR Gr(MaxV);
  Gr.DBL_Exec( );  //Тестирование функции DBL - поиск в глубину
  cout << "\n ===== Конец =====\n";
}