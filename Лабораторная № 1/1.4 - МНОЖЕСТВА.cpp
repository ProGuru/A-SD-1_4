#include <iostream>
#include <cstring> // для работы с strcmp
#include <ctime> // time.h для C, ctime для С++
#include <bits/stdc++.h>
#include <string.h>

const int Nmax = 16; // максимальное количество элементов во множестве
// (A ⋂ B ⋂ C) U D. В работе данной программы предполагается, что в каждом из заданных множеств нет повторяющихся элементов

struct Set
{
    char el; // элемент множества
    Set *next; // указатель на следующий элемент
    Set(char e, Set * n = nullptr): el(e), next(n) {} // конструктор структуры. *** При инициализации указатель на следующий элемент = 0? ***
    ~Set() {delete next;} // деструктор структуры. В теле освобождение памяти выделенного на указатель
};

Set *New_Set(char X[]) // функция заполнения списка
{
Set *temp; // буфер
Set *LX = new Set(0); // выделение памяти под обнулённый указатель на начало списка
for (int i = 0; i < strlen(X); i++)
{
    if (i == 0) // при первои итерации данные будут записаны в поле первой записи
    {
        LX->el = X[i];
        temp = LX; // в temp запишем указатель на данную запись
    }
    else
    {
    Set *p = new Set(X[i]); // выделение памяти под новый элемент
    temp->next = p; // в предыдущую запись в поле указателя на следующий элемент запишем эту запись
    temp = p;
    }
}
return LX; // возвращаем указатель на начало списка
}

// Функция для преобразования множества из массива символов в массив битов
void BitArray(char *a, int long *bA) // в функцию передается указатель на первый элемент массива a[]. Запись BitArray(char a[]) будет аналогичной
{
    for (int i = 0; a[i]; ++i)
    {
        bA[a[i]<='9'?a[i]-'0':a[i]-'A'+10] = 1; // устанавливаем в 1 биты, соответствующие каждому символу из А. Запись a[i]<='9'?a[i]-'0':a[i]-'A'+10 является тернарной функцией
    }
}

// Обратное преобразование множества из массив битов в массив символов в виде функции
void BitsToChar(char *X, int long *randX)
{
    int k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if (randX[i]) 
        {
            X[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    X[k++] = '\0';
}

// Функция для преобразования множества из массива символов в машинное слово
int CompWord(char *a)
{
    unsigned short int wA = 0; // так как размер универсума не превосходит 16 символов, то для машинного слова будет достаточно типа переменной short int
    for (int i = 0; a[i]; ++i)
    {
        wA |= (1 << (a[i]<='9'?a[i]-'0':a[i]-'A'+10)); // |= это оператор присвоения битового "или", аналогичен a |= b ->  a = a | b. << - оператор побитового сдвига.
    }
    return wA;
}

int main() {
    using namespace std;

    srand(time(nullptr)); // запуск датчика со случайной точки, зависящей от времени
    const long int q0 = 1000000; //  количество повторений цикла времени
    int long GenA[Nmax], GenB[Nmax], GenC[Nmax], GenD[Nmax]; // множество для генерации битов. Без переменных типа long в программе происходит обнуление множества А
    char A[Nmax] = {0}; // множество А.
    char B[Nmax] = {0}; // множество B.
    char C[Nmax] = {0}; // множество C.
    char D[Nmax] = {0}; // множество D.

// Генерация случайного подмножества методом генерирования последовательности битов


    int p, q; // константы для управления вероятностю появления нуля
    p = 5;
    q = 2;
    for (int i = 0; i < Nmax; i++) GenA[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenB[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenC[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenD[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0

    BitsToChar(A, GenA); // Преобразование множества из массива битов в массив символов
    BitsToChar(B, GenB); // Преобразование множества из массива битов в массив символов
    BitsToChar(C, GenC); // Преобразование множества из массива битов в массив символов
    BitsToChar(D, GenD); // Преобразование множества из массива битов в массив символов

// Добавление в программу возможности ввода элементов множества

    cout << "Введите те множества, которые будут введены вручную. Чтобы все множества были созданы случайно - нажмите 0" << endl;
    
    string stringForManualInput;
    cin >> stringForManualInput;

    // Проверка множеств на правильность введённых символов
    for (int i = 0; i < stringForManualInput.size(); i++)
    {
        if (stringForManualInput == "0")
        {
            break;
        }
        
        if (((int)stringForManualInput[i] < 65) || ((int)stringForManualInput[i] > 68)) { // Правильность символов отпределяется по их ASCII коду
            cout << "Введены неверные символы" << endl;
            return 0;
        }
    }

    string set;
    // Проверяем множество, если оно есть - вводим его
    if (stringForManualInput.find('A') != stringForManualInput.npos) { 
        cout << "Введите множество " << "A:" << endl;
        cin >> set;
        if (set.size() > Nmax)
        {
            cout << "Введено слишком много символов" << endl;
            return 0;
        }
        
        for (int i = 0; i < set.size(); i++) {
            if (!((((int)set[i] >= 48) && ((int)set[i] <= 57)) || (((int)set[i] >= 65) && ((int)set[i] <= 70)))) { // Правильность символов отпределяется по их ASCII коду
                cout << "Введены неверные символы" << endl;
                return 0;
            }
        }

        for (int i = 0; i < set.size(); i++) {
            A[i] = set[i];
        }
        A[set.size()] = '\0';
        BitArray(A, GenA);
        //BitsToChar(A, GenA); // Преобразование множества из массива битов в массив символов
    }

    // Проверяем множество, если оно есть - вводим его
    if (stringForManualInput.find('B') != stringForManualInput.npos) { 
        cout << "Введите множество " << "B:" << endl;
        cin >> set;
        if (set.size() > Nmax)
        {
            cout << "Введено слишком много символов" << endl;
            return 0;
        }
        
        for (int i = 0; i < set.size(); i++) {
            if (!((((int)set[i] >= 48) && ((int)set[i] <= 57)) || (((int)set[i] >= 65) && ((int)set[i] <= 70)))) { // Правильность символов отпределяется по их ASCII коду
                cout << "Введены неверные символы" << endl;
                return 0;
            }
        }

        for (int i = 0; i < set.size(); i++) {
            B[i] = set[i];
        }
        B[set.size()] = '\0';
        BitArray(B, GenB);
        //BitsToChar(B, GenB); // Преобразование множества из массива битов в массив символов
    }

    // Проверяем множество, если оно есть - вводим его
    if (stringForManualInput.find('C') != stringForManualInput.npos) { 
        cout << "Введите множество " << "C:" << endl;
        cin >> set;
        if (set.size() > Nmax)
        {
            cout << "Введено слишком много символов" << endl;
            return 0;
        }
        
        for (int i = 0; i < set.size(); i++) {
            if (!((((int)set[i] >= 48) && ((int)set[i] <= 57)) || (((int)set[i] >= 65) && ((int)set[i] <= 70)))) { // Правильность символов отпределяется по их ASCII коду
                cout << "Введены неверные символы" << endl;
                return 0;
            }
        }

        for (int i = 0; i < set.size(); i++) {
            C[i] = set[i];
        }
        C[set.size()] = '\0';
        BitArray(C, GenC);
        //BitsToChar(C, GenC); // Преобразование множества из массива битов в массив символов
    }

    // Проверяем множество, если оно есть - вводим его
    if (stringForManualInput.find('D') != stringForManualInput.npos) { 
        cout << "Введите множество " << "D:" << endl;
        cin >> set;
        if (set.size() > Nmax)
        {
            cout << "Введено слишком много символов" << endl;
            return 0;
        }
        
        for (int i = 0; i < set.size(); i++) {
            if (!((((int)set[i] >= 48) && ((int)set[i] <= 57)) || (((int)set[i] >= 65) && ((int)set[i] <= 70)))) { // Правильность символов отпределяется по их ASCII коду
                cout << "Введены неверные символы" << endl;
                return 0;
            }
        }

        for (int i = 0; i < set.size(); i++) {
            D[i] = set[i];
        }
        D[set.size()] = '\0';
        BitArray(D, GenD);
        //BitsToChar(D, GenD); // Преобразование множества из массива битов в массив символов
    }

// Преобразование множества из массива символов в машинное слово

    unsigned short int wA = CompWord(A);
    unsigned short int wB = CompWord(B);
    unsigned short int wC = CompWord(C);
    unsigned short int wD = CompWord(D);

// Вычисление 5-го множества (Е) с помощью множеств из массива символов

    int bE[Nmax]; // пустой массив символов - результат вычисления

    int i, j; // инизиализация переменных для цикла

    clock_t begin_3 = clock(); // начальный отчёт времени
    for (j = 0; j < q0; j++)
    {
        for (i = 0; i < Nmax; i++)
        {
            bE[i] = (GenA[i] && GenB[i] && GenC[i]) || GenD[i];
        }
        bE[Nmax] = '\0'; // завершающий нуль-символ в конце массива
    }
    clock_t end_3 = clock() - begin_3; // конечный отчёт времени
    
// Вычисление 5-го множества (Е) с помощью множеств в виде машинных слов

    unsigned short int wE; // Объявляем переменную - результат вычисления логической задачи
    clock_t begin_4 = clock(); // начальный отчёт времени
    for (j = 0; j < q0; j++)
    {
    wE = (wA & wB & wC) | wD;
    }
    clock_t end_4 = clock() - begin_4; // конечный отчёт времени

// Обратное преобразование множества из массив битов в массив символов

    char E_3[Nmax]; // результат вычисления
    int k = 0;
    for (i = 0; i < Nmax; i++)
    {
        if (bE[i]) 
        {
            E_3[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E_3[k++] = '\0';

// Обратное преобразование множества из машинное слова в массив символов

    char E_4[Nmax]; // результат преобраования из машинного слова
    k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if ((wE >> i) & 1)
        {
            E_4[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E_4[k++] = '\0';

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// вычисление множества с помощью алгоритма работы с множествами
// поиск одинаковых элементов во множествах А, В и С
    char E_1[Nmax]; // результат вычисления  
    bool v = true;
    int l, t;

    clock_t begin_1 = clock(); // начальный отчёт времени
    for (t = 0; t < q0; t++)
    {
        k = 0; // счётчик для индексирования злементов во множество E  
        for (i = 0; i < strlen(A); ++i)
        {
            for (j = 0; j < strlen(B); ++j)
            {
                for (l = 0; l < strlen(C); ++l)
                {
                    if ((A[i] == B[j]) && (B[j] == C[l]) && (A[i] == C[l]))
                    {
                        E_1[k] = A[i]; // здесь можно было бы присвоить B[j] или C[l]
                        k++; // индекс для множества E
                    }
                    
                }
                
            }
            
        }

        // Добавляем к полученному множеству множество D
        for (i = 0; i < strlen(D); ++i)
        {
            for (j = 0; j < k; ++j)
            {
                if (D[i] == E_1[j])
                {
                    v = false;
                }
                
            }
            if (v) // Если во множествах D и E есть есть отличающийся элемент...
            {
                E_1[k] = D[i]; // ...то он попадает в конец массива.
                k++;
            }
            v = true; // "сбрасываем" наш индикатор

        }
        E_1[k] = '\0'; // ставим в конце строки завершающий нуль-символ
    }
    clock_t end_1 = clock() - begin_1; // конечный отчёт времени
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // преобразеум множества в линейные списки, тип будущего списка ОЛС (односвязный линейный список)

    // преобразеум множества в линейные списки, тип будущего списка ОЛС (односвязный линейный список)

    Set *LA = New_Set(A);
    Set *LB = New_Set(B);
    Set *LC = New_Set(C);
    Set *LD = New_Set(D);


    // поиск одинаковых элементов во множествах А, В и С
    Set *LE = new Set(0); // выделение памяти под обнулённый указатель на начало списка
    Set *temp; // буфер

    clock_t begin_2 = clock(); // начальный отчёт времени
    for (t = 0; t < q0; t++)
    {
    delete LE;
    Set *LE = new Set(0); // выделение памяти под обнулённый указатель на начало списка
    Set *temp; // буфер
        for (Set *d = LA; d; d = d->next)
        {
            for (Set *m = LB; m; m = m->next)
            {
                for (Set *kp = LC; kp; kp = kp->next)
                {
                    if ((d->el == m->el) && (kp->el == m->el) && (d->el == kp->el)) // почему-то не получается (d->el == m->el == kp->el)
                    {
                        if (LE->el == 0) // при первои итерации данные будут записаны в поле первой записи
                        {
                            LE->el = d->el;
                            temp = LE; 
                        }
                        else
                        {
                        Set *p = new Set(d->el); // выделение памяти под новый элемент
                        temp->next = p; // в предыдущую запись в поле указателя на следующий элемент запишем эту запись
                        temp = p;
                        }
                    }
                    
                }
                
            }
            
            
        }

        // Добавляем к полученному множеству множество D
        v = true;
        Set *kp = LD;
        Set *m = LE;
        for (kp; kp; kp = kp->next)
        {
            m = LE; // ставим указатель на начало списка Е
            while (m)
            {
                if (m->el == kp->el) // проверяем, нет ли повторяющихся элементов множества
                {
                    v = false;
                }
                temp = m; // переменная temp уже была объявлена ранее, в ней мы сохраним последнюю запись в цепочке цикла
                m = m->next;
            }
            if (v) // Если во множествах D и E есть есть отличающийся элемент, то он будет записан в конец списка Е
            {
                Set *p = new Set(kp->el); // выделение памяти под новый элемент
                temp->next = p;
            }
            v = true; // "сбрасываем" наш индикатор
        }
    }
    clock_t end_2 = clock() - begin_2; // конечный отчёт времени

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Вывод результата
    cout << endl << "А: ";
    for (int i = 0; A[i]; ++i)
    {
        cout << A[i];
    }

    cout << endl << "B: ";
    for (int i = 0; B[i]; ++i)
    {
        cout << B[i];
    }

    cout << endl << "C: ";
    for (int i = 0; C[i]; ++i)
    {
        cout << C[i];
    }

    cout << endl << "D: ";
    for (int i = 0; D[i]; ++i)
    {
        cout << D[i];
    }


    cout << endl << "Результат логических вычислений с помощью массивов символов: \n";
    for (int i = 0; E_1[i]; ++i)
    {
        cout << E_1[i];
    }
    cout << "\nВремя обработки: " <<  (float)(end_1) / CLOCKS_PER_SEC << " c при количестве итераций " << q0 << endl << endl;

    cout << "Результат логических вычислений с помощью массива битов: \n";
    for (int i = 0; E_3[i]; ++i)
    {
        cout << E_3[i];
    }
    cout << "\nВремя обработки: " <<  (float)(end_3) / CLOCKS_PER_SEC << " c при количестве итераций " << q0 << endl << endl;

    cout << "Результат логических вычислений с помощью машинных слов: \n";
        for (int i = 0; E_4[i]; ++i)
    {
        cout << E_4[i];
    }
    cout << "\nВремя обработки: " << (float)(end_4) / CLOCKS_PER_SEC << " c при количестве итераций " << q0 << endl << endl;


    cout << "Результат логических вычислений с помощью списков: \n";
    for (Set *p = LE; p; p = p->next)
    {
        cout << p->el;
    }
    cout << "\nВремя обработки: " <<  (float)(end_2) / CLOCKS_PER_SEC << " c при количестве итераций " << q0 << endl << endl;
    
    return 0;
}