#include <iostream>
#include <cstring> // для работы с strlen

// (A ⋂ B ⋂ C) U D. В работе данной программы предполагается, что в каждом из заданных множеств нет повторяющихся элементов

struct Set
{
    char el; // элемент множества
    Set *next; // указатель на следующий элемент
    Set(char e, Set * n = nullptr): el(e), next(n) {} // конструктор структуры. *** При инициализации указатель на следующий элемент = 0? ***
    ~Set() {delete next;} // деструктор структуры. В теле освобождение памяти выделенного на указатель
};
//----------------------------------------------------------------------------------------------------------------------------
    Set *New_Set(char X[]) // функция заполнения списка
    {
    Set *temp; // буфер
    Set *LX = new Set(0); // выделение памяти под обнулённый указатель на начало списка
    for (int i = 0; i < strlen(X); i++)
    {
        if (i == 0) // при первои итерации данные будут записаны в поле первой записи
        {
            LX->el = X[i];
            temp = LX; // в temp запишем указатель на данную запись
        }
        else
        {
        Set *p = new Set(X[i]); // выделение памяти под новый элемент
        temp->next = p; // в предыдущую запись в поле указателя на следующий элемент запишем эту запись
        temp = p;
        }
    }
    return LX; // возвращаем указатель на начало списка
    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;

    char Uni[] = {"0123456789ABCDEF"}; // множество - универсум
    const int Nmax = 16; // максимальное количество элементов во множестве
    char A[] = {'1', '8', 'F', '\0'}; // множество А. Обязательно в конце массива добавляем завершающий нуль-символ
    char B[] = {'2','8', '5', 'D', 'F', '\0'}; // множество B. Обязательно в конце массива добавляем завершающий нуль-символ
    char C[] = {'1', '2', '6', '8', 'F', '\0'}; // множество C. Обязательно в конце массива добавляем завершающий нуль-символ
    char D[] = {'1', '8', '9', 'B', '\0'}; // множество D. Обязательно в конце массива добавляем завершающий нуль-символ
    char E[Nmax]; // результат вычисления

    // преобразеум множества в линейные списки, тип будущего списка ОЛС (односвязный линейный список)

    Set *LA = New_Set(A);
    Set *LB = New_Set(B);
    Set *LC = New_Set(C);
    Set *LD = New_Set(D);


    // поиск одинаковых элементов во множествах А, В и С
    Set *temp; // буфер
    Set *LE = new Set(0); // выделение памяти под обнулённый указатель на начало списка
    for (Set *d = LA; d; d = d->next)
    {
        for (Set *m = LB; m; m = m->next)
        {
            for (Set *kp = LC; kp; kp = kp->next)
            {
                if ((d->el == m->el) && (kp->el == m->el) && (d->el == kp->el)) // почему-то не получается (d->el == m->el == kp->el)
                {
                    if (LE->el == 0) // при первои итерации данные будут записаны в поле первой записи
                    {
                        LE->el = d->el;
                        temp = LE; 
                    }
                    else
                    {
                    Set *p = new Set(d->el); // выделение памяти под новый элемент
                    temp->next = p; // в предыдущую запись в поле указателя на следующий элемент запишем эту запись
                    temp = p;
                    }
                }
                
            }
            
        }
        
        
    }

    // Добавляем к полученному множеству множество D
    bool v = true;
    Set *kp = LD;
    Set *m = LE;
    for (kp; kp; kp = kp->next)
    {
        m = LE; // ставим указатель на начало списка Е
        while (m)
        {
            if (m->el == kp->el) // проверяем, нет ли повторяющихся элементов множества
            {
                v = false;
            }
            temp = m; // переменная temp уже была объявлена ранее, в ней мы сохраним последнюю запись в цепочке цикла
            m = m->next;
        }
        if (v) // Если во множествах D и E есть есть отличающийся элемент, то он будет записан в конец списка Е
        {
            Set *p = new Set(kp->el); // выделение памяти под новый элемент
            temp->next = p;
        }
        v = true; // "сбрасываем" наш индикатор
    }
    // Вывод на экран полученного множества
    for (Set *p = LE; p; p = p->next)
    {
        cout << p->el << endl;
    }
    return 0;
}