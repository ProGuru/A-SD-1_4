#include <iostream>
#include <cstring> // для работы с strcmp

// (A ⋂ B ⋂ C) U D. В работе данной программы предполагается, что в каждом из заданных множеств нет повторяющихся элементов

// Функция для преобразования множества из массива символов в массив битов
void BitArray(char *a, int *bA) // в функцию передается указатель на первый элемент массива a[]. Запись BitArray(char a[]) будет аналогичной
{
    for (int i = 0; a[i]; ++i)
    {
        bA[a[i]<='9'?a[i]-'0':a[i]-'A'+10] = 1; // устанавливаем в 1 биты, соответствующие каждому символу из А. Запись a[i]<='9'?a[i]-'0':a[i]-'A'+10 является тернарной функцией
    }
}

// Функция для преобразования множества из массива символов в машинное слово
int CompWord(char *a)
{
    unsigned short int wA = 0; // так как размер универсума не превосходит 16 символов, то для машинного слова будет достаточно типа переменной short int
    for (int i = 0; a[i]; ++i)
    {
        wA |= (1 << (a[i]<='9'?a[i]-'0':a[i]-'A'+10)); // |= это оператор присвоения битового "или", аналогичен a |= b ->  a = a | b. << - оператор побитового сдвига.
    }
    return wA;
}

int main()
{
    char Uni[] = {"0123456789ABCDEF"}; // множество - универсум
    const int Nmax = 16; // максимальное количество элементов во множестве
    char A[] = {'1', '8', 'F', '\0'}; // множество А. Обязательно в конце массива добавляем завершающий нуль-символ
    char B[] = {'2','8', '5', 'D', 'F', '\0'}; // множество B. Обязательно в конце массива добавляем завершающий нуль-символ
    char C[] = {'1', '2', '6', '8', 'F', '\0'}; // множество C. Обязательно в конце массива добавляем завершающий нуль-символ
    char D[] = {'1', '8', '9', 'B', '\0'}; // множество D. Обязательно в конце массива добавляем завершающий нуль-символ
    char E[Nmax]; // результат вычисления

// Преобразование множества из массива символов в массив битов

    int bA[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(A, bA); // в функцию передаются указатели на массивы
    bA[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bB[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(B, bB); // в функцию передаются указатели на массивы
    bB[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bC[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(C, bC); // в функцию передаются указатели на массивы
    bC[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bD[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(D, bD); // в функцию передаются указатели на массивы
    bD[Nmax] = '\0'; // завершающий нуль-символ в конце массива

// Преобразование множества из массива символов в машинное слово

    unsigned short int wA = CompWord(A);
    unsigned short int wB = CompWord(B);
    unsigned short int wC = CompWord(C);
    unsigned short int wD = CompWord(D);

// Вычисление 5-го множества (Е) с помощью множеств из массива символов

    int bE[Nmax]; // пустой массив символов - результат вычисления
    for (int i = 0; i < Nmax; i++)
    {
        bE[i] = (bA[i] && bB[i] && bC[i]) || bD[i];
    }
    bE[Nmax] = '\0'; // завершающий нуль-символ в конце массива

// Вычисление 5-го множества (Е) с помощью множеств в виде машинных слов

    unsigned short int wE; // Объявляем переменную - результат вычисления логической задачи
    wE = (wA & wB & wC) | wD;

// Обратное преобразование множества из массив битов в массив символов

    int k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if (bE[i]) 
        {
            E[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E[k++] = '\0';

// Обратное преобразование множества из машинное слова в массив символов

    char E_2[Nmax]; // результат преобраования из машинного слова
    k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if ((wE >> i) & 1)
        {
            E_2[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E_2[k++] = '\0';

// Вывод результата
    std::cout << "Результат обратного преобразования из массива битов в массив символов: ";
    for (int i = 0; E[i]; ++i)
    {
        std::cout << E[i];
    }
    std::cout << std::endl << "Результат обратного преобразования из машинного слова в массив символов: ";
        for (int i = 0; E_2[i]; ++i)
    {
        std::cout << E_2[i];
    }

// Проверка:
    if (strcmp(E, E_2) != 0)
    {
        std::cout << std::endl << "Результаты НЕ совпадают!";
    }
    else std::cout << std::endl << "Результаты совпадают!";
    
    return 0;
}