#include <iostream>
#include <cstring> // для работы с strcmp
#include <time.h>

const int Nmax = 16; // максимальное количество элементов во множестве
// (A ⋂ B ⋂ C) U D. В работе данной программы предполагается, что в каждом из заданных множеств нет повторяющихся элементов

// Функция для преобразования множества из массива символов в массив битов
void BitArray(char *a, int *bA) // в функцию передается указатель на первый элемент массива a[]. Запись BitArray(char a[]) будет аналогичной
{
    for (int i = 0; a[i]; ++i)
    {
        bA[a[i]<='9'?a[i]-'0':a[i]-'A'+10] = 1; // устанавливаем в 1 биты, соответствующие каждому символу из А. Запись a[i]<='9'?a[i]-'0':a[i]-'A'+10 является тернарной функцией
    }
}

// Обратное преобразование множества из массив битов в массив символов в виде функции
void BitsToChar(char *X, int *randX)
{
    int k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if (randX[i]) 
        {
            X[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    X[k++] = '\0';
}

// Функция для преобразования множества из массива символов в машинное слово
int CompWord(char *a)
{
    unsigned short int wA = 0; // так как размер универсума не превосходит 16 символов, то для машинного слова будет достаточно типа переменной short int
    for (int i = 0; a[i]; ++i)
    {
        wA |= (1 << (a[i]<='9'?a[i]-'0':a[i]-'A'+10)); // |= это оператор присвоения битового "или", аналогичен a |= b ->  a = a | b. << - оператор побитового сдвига.
    }
    return wA;
}

int main()
{
    srand(time(0)); // запуск датчика со случайной точки, зависящей от времени
    int GenA[Nmax], GenB[Nmax], GenC[Nmax], GenD[Nmax]; // множество для генерации битов
    char A[Nmax] = {0}; // множество А.
    char B[Nmax] = {0}; // множество B.
    char C[Nmax] = {0}; // множество C.
    char D[Nmax] = {0}; // множество D.
    char E[Nmax]; // результат вычисления

// Генерация случайного подмножества методом генерирования последовательности битов

    int p, q; // константы для управления вероятностю появления нуля
    p = 5;
    q = 2;
    for (int i = 0; i < Nmax; i++) GenA[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenB[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenC[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0
    for (int i = 0; i < Nmax; i++) GenD[i] = (rand()%p>q); // если результат rand()%p > q, то во множество запишется логическая 1, иначе запишется 0

    BitsToChar(A, GenA); // Преобразование множества из массива битов в массив символов
    BitsToChar(B, GenB); // Преобразование множества из массива битов в массив символов
    BitsToChar(C, GenC); // Преобразование множества из массива битов в массив символов
    BitsToChar(D, GenD); // Преобразование множества из массива битов в массив символов

// Преобразование множества из массива символов в массив битов

    int bA[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(A, bA); // в функцию передаются указатели на массивы
    bA[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bB[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(B, bB); // в функцию передаются указатели на массивы
    bB[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bC[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(C, bC); // в функцию передаются указатели на массивы
    bC[Nmax] = '\0'; // завершающий нуль-символ в конце массива

    int bD[Nmax] = {0}; // память под массив должна выделяться в теле функции
    BitArray(D, bD); // в функцию передаются указатели на массивы
    bD[Nmax] = '\0'; // завершающий нуль-символ в конце массива

// Преобразование множества из массива символов в машинное слово

    unsigned short int wA = CompWord(A);
    unsigned short int wB = CompWord(B);
    unsigned short int wC = CompWord(C);
    unsigned short int wD = CompWord(D);

// Вычисление 5-го множества (Е) с помощью множеств из массива символов

    int bE[Nmax]; // пустой массив символов - результат вычисления
    for (int i = 0; i < Nmax; i++)
    {
        bE[i] = (bA[i] && bB[i] && bC[i]) || bD[i];
    }
    bE[Nmax] = '\0'; // завершающий нуль-символ в конце массива

// Вычисление 5-го множества (Е) с помощью множеств в виде машинных слов

    unsigned short int wE; // Объявляем переменную - результат вычисления логической задачи
    wE = (wA & wB & wC) | wD;

// Обратное преобразование множества из массив битов в массив символов

    int k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if (bE[i]) 
        {
            E[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E[k++] = '\0';

// Обратное преобразование множества из машинное слова в массив символов

    char E_2[Nmax]; // результат преобраования из машинного слова
    k = 0;
    for (int i = 0; i < Nmax; i++)
    {
        if ((wE >> i) & 1)
        {
            E_2[k++] = (i<=9?i+'0':i+'A'-10);
        }
    }
    E_2[k++] = '\0';

// Вывод результата
    std::cout << "Результат обратного преобразования из массива битов в массив символов: ";
    for (int i = 0; E[i]; ++i)
    {
        std::cout << E[i];
    }
    std::cout << std::endl << "Результат обратного преобразования из машинного слова в массив символов: ";
        for (int i = 0; E_2[i]; ++i)
    {
        std::cout << E_2[i];
    }

// Проверка:
    if (strcmp(E, E_2) != 0)
    {
        std::cout << std::endl << "Результаты НЕ совпадают!";
    }
    else std::cout << std::endl << "Результаты совпадают!";
    
    return 0;
}